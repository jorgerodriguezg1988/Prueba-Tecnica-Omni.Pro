"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleCyLogEvents = void 0;
const helper_1 = require("./helper");
const common_1 = require("../common");
const command_names_1 = require("../common/command-names");
const request_events_1 = require("./request-events");
const dbg = 'cypress-allure:cy-events';
const UNCAUGHT_EXCEPTION_NAME = 'uncaught exception';
const UNCAUGHT_EXCEPTION_STATUS = 'broken';
const failedStatus = 'failed';
const passedStatus = 'passed';
const brokenStatus = 'broken';
const attachRequests = (allureAttachRequests, command, opts) => {
    var _a, _b, _c;
    const debug = (0, helper_1.logClient)(dbg);
    const maxParamLength = 70;
    const compact = (_a = opts.compactAttachments) !== null && _a !== void 0 ? _a : true;
    const indent = compact ? undefined : ' ';
    debug(command);
    const logsAttr = (_c = (_b = command.attributes) === null || _b === void 0 ? void 0 : _b.logs) !== null && _c !== void 0 ? _c : [];
    const consoleProps = logsAttr.map(t => { var _a, _b; return (_b = (_a = t.attributes) === null || _a === void 0 ? void 0 : _a.consoleProps) === null || _b === void 0 ? void 0 : _b.call(_a); });
    debug('consoleProps:');
    debug(consoleProps);
    // t.Command for less than 13.x cypress
    const logs = consoleProps.filter(t => t.name === command_names_1.COMMAND_REQUEST || t.Command === command_names_1.COMMAND_REQUEST);
    const getRequests = () => {
        const logsMapped = logs.map(t => { var _a; return (_a = t.props) !== null && _a !== void 0 ? _a : t; }); // support  cypress < 13.x
        if (logsMapped.every(t => !!t.Requests)) {
            // several requests if there are come redirects
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return logsMapped.flatMap(t => t.Requests.map((x) => { var _a; return (Object.assign(Object.assign({}, x), { duration: (_a = t.Yielded) === null || _a === void 0 ? void 0 : _a.duration })); }));
        }
        if (logsMapped.every(t => !!t.Request)) {
            return logsMapped.map(t => { var _a; return (Object.assign(Object.assign({}, t.Request), { duration: (_a = t.Yielded) === null || _a === void 0 ? void 0 : _a.duration })); });
        }
        return undefined;
    };
    const requests = getRequests();
    if (!requests) {
        return;
    }
    const allRequests = requests.filter(r => !!r);
    allRequests.forEach((req) => {
        var _a, _b, _c, _d, _e;
        const reqHeaders = { obj: req['Request Headers'], name: 'Request Headers' };
        const reqBody = { obj: req['Request Body'], name: 'Request Body' };
        const resHeaders = { obj: req['Response Headers'], name: 'Response Headers' };
        const resBody = { obj: req['Response Body'], name: 'Response Body' };
        const resStatusParam = { name: 'Response Status', value: `${(_a = req['Response Status']) !== null && _a !== void 0 ? _a : ''}` };
        const reqUrlParam = { name: 'Request URL', value: `${(_b = req['Request URL']) !== null && _b !== void 0 ? _b : ''}` };
        const stepUrl = reqUrlParam.value.replace((_e = (_c = Cypress.config('baseUrl')) !== null && _c !== void 0 ? _c : (0, common_1.baseUrlFromUrl)((_d = Cypress.config('browserUrl')) !== null && _d !== void 0 ? _d : '')) !== null && _e !== void 0 ? _e : '', '');
        const stepStatus = resStatusParam.value !== '200' ? 'broken' : 'passed';
        /*if (reqNumber === 0) {
          Cypress.Allure.parameters({ name: 'duration', value: req.duration });
        }*/
        if (allRequests.length > 1) {
            Cypress.Allure.startStep(`request: ${resStatusParam.value} ${stepUrl}`);
        }
        const attaches = [reqBody, reqHeaders, resBody, resHeaders].map(t => (Object.assign(Object.assign({}, t), { stringified: (0, command_names_1.stringify)(t.obj, true, indent) })));
        const shortAttaches = attaches.filter(a => a.stringified.length < maxParamLength);
        const longAttaches = attaches.filter(a => a.stringified.length >= maxParamLength);
        if (allRequests.length === 1) {
            Cypress.Allure.parameters(resStatusParam);
        }
        Cypress.Allure.parameters(reqUrlParam, ...shortAttaches.map(a => ({ name: a.name, value: a.stringified })));
        if (allureAttachRequests) {
            longAttaches
                .filter(t => !!t.obj)
                .forEach(attach => {
                Cypress.Allure.attachment(attach.name, attach.stringified, 'application/json');
            });
        }
        if (allRequests.length > 1) {
            Cypress.Allure.endStep(stepStatus);
        }
    });
};
const handleCyLogEvents = (runner, events, config) => {
    const debug = (0, helper_1.logClient)(dbg);
    const { ignoreCommands, wrapCustomCommands, allureLogCyCommands, spyOnRequests } = config;
    const customCommands = [];
    const allureAttachRequests = Cypress.env('allureAttachRequests')
        ? Cypress.env('allureAttachRequests') === 'true' || Cypress.env('allureAttachRequests') === true
        : false;
    const allureCompactAttachmentsRequests = Cypress.env('allureCompactAttachments')
        ? Cypress.env('allureCompactAttachments') === 'true' || Cypress.env('allureCompactAttachments') === true
        : true;
    const isEndLogCommand = (name) => {
        return name === 'end-logGroup';
    };
    const isLogCommand = (isLog, name) => {
        return isLog && !(0, command_names_1.ignoreAllCommands)(ignoreCommands).includes(name) && !Object.keys(Cypress.Allure).includes(name);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const wrappedFn = (originalFn) => (...fnargs) => {
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const currentCmd = (_b = (_a = Cypress).state) === null || _b === void 0 ? void 0 : _b.call(_a).current;
        events.emit('cmd:started:tech', currentCmd, true);
        const res = originalFn(...fnargs);
        const end = () => events.emit('cmd:ended:tech', currentCmd, true);
        if ((res === null || res === void 0 ? void 0 : res.then) && !(res === null || res === void 0 ? void 0 : res.should)) {
            // for promises returned from commands
            res.then(() => {
                end();
            });
        }
        else {
            cy.doSyncCommand(() => {
                end();
            });
        }
        return res;
    };
    const wrapCustomCommandsFn = (commands, isExclude) => {
        const origAdd = Cypress.Commands.add;
        Cypress.on('command:enqueued', () => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const queue = () => cy.queue;
            // swap if next chainer is 'should'
            // should be done for all child commands ?
            const swapCmd = () => {
                const custId = queue().queueables.findIndex((t, i) => { var _a; return i >= queue().index && ((_a = t.attributes) === null || _a === void 0 ? void 0 : _a.name) === 'doSyncCommand'; });
                const next = custId + 1;
                if (queue().queueables.length > next && ['assertion'].includes(queue().queueables[next].attributes.type)) {
                    (0, common_1.swapItems)(queue().queueables, custId, next);
                    swapCmd();
                }
            };
            swapCmd();
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Cypress.Commands.add = (...args) => {
            const fnName = args[0];
            const fn = typeof args[1] === 'function' ? args[1] : args[2];
            const opts = typeof args[1] === 'object' ? args[1] : undefined;
            if (!fnName ||
                typeof fnName !== 'string' ||
                (0, command_names_1.ignoreAllCommands)(ignoreCommands).includes(fnName) ||
                // wrap only specified commands
                (commands.length > 0 && commands.includes(fnName) && isExclude) ||
                (commands.length > 0 && !commands.includes(fnName) && !isExclude)) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                origAdd(...args);
                return;
            }
            if (fn && opts) {
                origAdd(fnName, opts, wrappedFn(fn));
            }
            else if (fn) {
                origAdd(fnName, wrappedFn(fn));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                origAdd(...args);
            }
        };
    };
    const wrapCustomCommandsRes = wrapCustomCommands();
    if (allureLogCyCommands() && wrapCustomCommandsRes) {
        const commands = Array.isArray(wrapCustomCommandsRes) ? wrapCustomCommandsRes : [];
        let isExclude = false;
        let commadsFixed = commands;
        if (!(commands === null || commands === void 0 ? void 0 : commands.every(c => c.startsWith('!'))) || !(commands === null || commands === void 0 ? void 0 : commands.every(c => !c.startsWith('!')))) {
            (0, common_1.logWithPackage)('warn', 'wrapCustomCommands environment variable - should either all start from "!" or not');
        }
        if (commands === null || commands === void 0 ? void 0 : commands.every(c => c.startsWith('!'))) {
            isExclude = true;
            commadsFixed = commands === null || commands === void 0 ? void 0 : commands.map(t => t.slice(1));
        }
        wrapCustomCommandsFn(commadsFixed, isExclude);
    }
    const wrapCypressGroupCommands = () => {
        const groupedCommands = ['session', 'within'];
        groupedCommands.forEach(cmd => {
            Cypress.Commands.overwrite(cmd, function (originalFn, ...args) {
                const fn = originalFn;
                if ((0, command_names_1.ignoreAllCommands)(ignoreCommands).includes(cmd)) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    return fn(...args);
                }
                return wrappedFn(fn)(...args);
            });
        });
    };
    if (allureLogCyCommands()) {
        wrapCypressGroupCommands();
    }
    const requests = [];
    // should be beforeEach (not before) to get env variable value from test config
    beforeEach(`${common_1.packageLog}`, () => {
        // this way can save bodies for intercepted requests
        var _a;
        const requestsToSpy = (_a = spyOnRequests === null || spyOnRequests === void 0 ? void 0 : spyOnRequests()) !== null && _a !== void 0 ? _a : [];
        cy.allure().parameter('To access request bodies', "add environment variable: `allureAddBodiesToRequests`\n(value is requests split by comma that you wish to save, to save all set '*')");
        cy.allure().parameter('To skip this message', "add environment variable `allureSkipSteps: '*\\[cypress-allure-adapter\\]*' `");
        if (requestsToSpy.length > 0) {
            requestsToSpy.forEach(r => {
                cy.intercept(r).as('allure');
            });
        }
        else {
            cy.allure().step('will not intercept requests to save bodies');
        }
        requests.splice(0, requests.length);
    });
    (0, request_events_1.lgoRequestEvents)(requests, events);
    Cypress.on('log:added', (log) => {
        if (!allureLogCyCommands()) {
            return;
        }
        (0, command_names_1.withTry)('report log:added', () => {
            const logName = (0, command_names_1.logNameFn)(log);
            const logMessage = log.message;
            const chainerId = log.chainerId;
            const end = log.end || log.ended;
            const logState = log.state;
            const cmdMessage = (0, command_names_1.stepMessage)(logName, logMessage === 'null' ? '' : logMessage);
            if (!chainerId && end && logName !== command_names_1.COMMAND_REQUEST) {
                // synchronous log without commands
                Cypress.Allure.startStep(cmdMessage);
                let status = passedStatus;
                if (logName === 'WARNING') {
                    status = brokenStatus;
                }
                if (logState === 'failed') {
                    status = failedStatus;
                }
                Cypress.Allure.endStep(status);
            }
        });
    });
    const addCommandLogs = (command) => {
        var _a;
        if (!allureLogCyCommands()) {
            return;
        }
        if (isEndLogCommand((_a = command.attributes) === null || _a === void 0 ? void 0 : _a.name)) {
            Cypress.Allure.endStep();
            return;
        }
        const filtered = (0, command_names_1.filterCommandLog)(command, ignoreCommands).sort((aLog, bLog) => {
            var _a, _b;
            const attrA = (_a = aLog === null || aLog === void 0 ? void 0 : aLog.attributes) === null || _a === void 0 ? void 0 : _a.commandLogId;
            const attrB = (_b = bLog === null || bLog === void 0 ? void 0 : bLog.attributes) === null || _b === void 0 ? void 0 : _b.commandLogId;
            if (!attrA || !attrB) {
                return 0;
            }
            return attrA < attrB ? -1 : 1;
        });
        filtered.forEach(log => {
            var _a, _b, _c;
            const attr = log.attributes;
            const logName = (0, command_names_1.logNameFn)(attr);
            const logErr = attr === null || attr === void 0 ? void 0 : attr.error;
            const message = attr === null || attr === void 0 ? void 0 : attr.message;
            const groupEnd = attr === null || attr === void 0 ? void 0 : attr.groupEnd;
            const groupStart = attr === null || attr === void 0 ? void 0 : attr.groupStart;
            // const isEmitOnly = attr?.emitOnly;
            const logMessage = (0, command_names_1.stepMessage)(logName, message === 'null' ? '' : message);
            const consoleProps = (_a = attr === null || attr === void 0 ? void 0 : attr.consoleProps) === null || _a === void 0 ? void 0 : _a.call(attr);
            // console.log('logName');
            // console.log(logName);
            // console.log('attr');
            // console.log(attr);
            // console.log('consoleProps');
            // console.log(consoleProps);
            if (groupStart) {
                Cypress.Allure.startStep(logMessage);
                return;
            }
            // if (groupEnd) {
            //   Cypress.Allure.endStep();
            //   return;
            // }
            if (!groupEnd) {
                Cypress.Allure.startStep(logMessage);
            }
            if (logName !== 'assert' && message && message.length > command_names_1.ARGS_TRIM_AT) {
                Cypress.Allure.attachment(`${logMessage} args`, message, 'application/json');
            }
            let state = ((_b = consoleProps === null || consoleProps === void 0 ? void 0 : consoleProps.error) !== null && _b !== void 0 ? _b : logErr) ? failedStatus : passedStatus;
            let details = undefined;
            if (logName.indexOf(UNCAUGHT_EXCEPTION_NAME) !== -1) {
                const err = (_c = consoleProps === null || consoleProps === void 0 ? void 0 : consoleProps.props) === null || _c === void 0 ? void 0 : _c.Error;
                const isCommandFailed = command.state === 'failed';
                // when command failed we mark uncaught exception log as error,
                // in other cases it will be marked as broken
                state = isCommandFailed ? failedStatus : UNCAUGHT_EXCEPTION_STATUS;
                details = { message: err === null || err === void 0 ? void 0 : err.message, trace: err === null || err === void 0 ? void 0 : err.stack };
            }
            if (logName === 'WARNING') {
                state = brokenStatus;
            }
            Cypress.Allure.endStep(state, details);
        });
    };
    Cypress.on('command:start', (command) => {
        events.emit('cmd:started:tech', command);
    });
    Cypress.on('command:failed', (command) => {
        addCommandLogs(command);
        events.emit('cmd:ended:tech', command);
    });
    Cypress.on('command:end', (command) => {
        addCommandLogs(command);
        events.emit('cmd:ended:tech', command);
    });
    events.on('cmd:started:tech', (command, isCustom) => {
        const { message: cmdMessage } = (0, command_names_1.commandParams)(command);
        debug(`started tech: ${cmdMessage}`);
        if (isCustom) {
            customCommands.push(cmdMessage);
            // not start when custom because cypress already
            // fired event command:start
            return;
        }
        events.emit('cmd:started', command);
    });
    Cypress.Allure.on('cmd:started', (command) => {
        const { name, isLog, message: cmdMessage, args } = (0, command_names_1.commandParams)(command);
        if (!isLogCommand(isLog, name) || !allureLogCyCommands()) {
            return;
        }
        debug(`started: ${cmdMessage}`);
        Cypress.Allure.startStep(cmdMessage);
        (0, command_names_1.withTry)('report command:attachment', () => {
            const requestAndLogRequests = allureAttachRequests && name === command_names_1.COMMAND_REQUEST;
            if (!requestAndLogRequests && args.join(',').length > command_names_1.ARGS_TRIM_AT) {
                const content = args.join('\n');
                Cypress.Allure.attachment(`${cmdMessage} args`, content, 'application/json');
            }
        });
    });
    events.on('cmd:ended:tech', (command, isCustom) => {
        const { message: cmdMessage } = (0, command_names_1.commandParams)(command);
        const last = customCommands[customCommands.length - 1];
        if (last && last === cmdMessage) {
            customCommands.pop();
            // cypress ends custom commands right away
            // not end when custom started
            return;
        }
        events.emit('cmd:ended', command, isCustom);
    });
    Cypress.Allure.on('cmd:ended', (command, isCustom) => {
        const { name, isLog, state, message: cmdMessage } = (0, command_names_1.commandParams)(command);
        const status = state;
        if (!isLogCommand(isLog, name)) {
            return;
        }
        if (name === command_names_1.COMMAND_REQUEST) {
            (0, command_names_1.withTry)('report attach:requests', () => {
                attachRequests(allureAttachRequests, command, { compactAttachments: allureCompactAttachmentsRequests });
            });
        }
        if (!allureLogCyCommands()) {
            return;
        }
        debug(`ended ${isCustom ? 'CUSTOM' : ''}: ${cmdMessage}`);
        Cypress.Allure.endStep(status);
    });
};
exports.handleCyLogEvents = handleCyLogEvents;
